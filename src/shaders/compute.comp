#version 460

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba8) uniform writeonly image2D img;

void main() {
    vec2 norm_coordinates = (gl_GlobalInvocationID.xy + vec2(0.5)) / vec2(imageSize(img));

    const float zoom = 1.0;
    const vec2 center = vec2(-0.75, 0.0);

    vec2 view_size = vec2(3.5, 3.0) * zoom;

    vec2 c = center + (norm_coordinates - 0.5) * view_size;

    vec2 z = vec2(0.0, 0.0);
    float i;
    const float max_iter = 200.0;
    bool diverged = false;
    
    for (i = 0.0; i < max_iter; i++) {
        if (dot(z, z) > 2000.0 * 2000.0) {
            diverged = true;
            break;
        }
        
        z = vec2(
            z.x * z.x - z.y * z.y + c.x,
            2.0 * z.x * z.y + c.y
        );
    }

    const vec3 palette[8] = vec3[](
        vec3(0.0, 0.0, 0.0),
        vec3(0.5, 0.5, 0.5),
        vec3(1.0, 0.5, 0.5),
        vec3(0.5, 1.0, 0.5),
        vec3(0.5, 0.5, 1.0),
        vec3(0.5, 1.0, 1.0),
        vec3(1.0, 0.5, 1.0),
        vec3(1.0, 1.0, 0.5)
    );

    vec4 to_write;
    
    if (diverged) {
        const int nPalette = 8;
        float smoothed = log2(log2(dot(z, z)) / 2.0);
        float fColorIndex = sqrt(i + 10.0 - smoothed);
        
        float colorLerp = fract(fColorIndex);
        int colorIndexA = int(fColorIndex) % nPalette;
        int colorIndexB = (colorIndexA + 1) % nPalette;
        
        vec3 col = mix(palette[colorIndexA], palette[colorIndexB], colorLerp);
        to_write = vec4(col, 1.0);
    } else {
        to_write = vec4(0.0, 0.0, 0.0, 1.0);
    }

    imageStore(img, ivec2(gl_GlobalInvocationID.xy), to_write);
}
